{
  "version": 3,
  "sources": ["../../@noble/hashes/src/crypto.ts", "../../@noble/hashes/src/_assert.ts", "../../@noble/hashes/src/utils.ts", "../../@noble/hashes/src/_md.ts", "../../@noble/hashes/src/sha256.ts", "../../viem/node_modules/ox/core/TypedData.ts"],
  "sourcesContent": ["// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Assertion helpers\n * @module\n */\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction ahash(h: Hash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\nfunction aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, abytes, ahash, aexists, aoutput };\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray): Uint8Array =>\n  new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray): Uint32Array =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray): DataView =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport const rotr = (word: number, shift: number): number =>\n  (word << (32 - shift)) | (word >>> shift);\n/** The rotate left (circular left shift) operation for uint32 */\nexport const rotl = (word: number, shift: number): number =>\n  (word << shift) | ((word >>> (32 - shift)) >>> 0);\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport const byteSwap = (word: number): number =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): void {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async (): Promise<void> => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\nexport type CHashO = ReturnType<typeof wrapConstructorWithOpts>;\nexport type CHashXO = ReturnType<typeof wrapXOFConstructorWithOpts>;\n\nexport function wrapConstructor<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "import { aexists, aoutput } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n/**\n * Merkle-Damgard hash utils.\n * @module\n */\n\n/**\n * Polyfill for Safari 14\n */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a: number, b: number, c: number): number => (a & b) ^ (~a & c);\n\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a: number, b: number, c: number): number => (a & b) ^ (a & c) ^ (b & c);\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor, CHash } from './utils.js';\n\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\n\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    SHA256_W.fill(0);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n  protected A = 0xc1059ed8 | 0;\n  protected B = 0x367cd507 | 0;\n  protected C = 0x3070dd17 | 0;\n  protected D = 0xf70e5939 | 0;\n  protected E = 0xffc00b31 | 0;\n  protected F = 0x68581511 | 0;\n  protected G = 0x64f98fa7 | 0;\n  protected H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/** SHA2-256 hash function */\nexport const sha256: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/** SHA2-224 hash function */\nexport const sha224: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n", "import type * as abitype from 'abitype'\nimport * as AbiParameters from './AbiParameters.js'\nimport * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport type { Compute } from './internal/types.js'\nimport * as Json from './Json.js'\nimport * as Solidity from './Solidity.js'\n\nexport type TypedData = abitype.TypedData\nexport type Domain = abitype.TypedDataDomain\nexport type Parameter = abitype.TypedDataParameter\n\n// TODO: Make reusable for Viem?\nexport type Definition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n> = primaryType extends 'EIP712Domain'\n  ? EIP712DomainDefinition<typedData, primaryType>\n  : MessageDefinition<typedData, primaryType, primaryTypes>\n\nexport type EIP712DomainDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends 'EIP712Domain' = 'EIP712Domain',\n  ///\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n> = {\n  types?: typedData | undefined\n} & {\n  primaryType:\n    | 'EIP712Domain'\n    | (primaryType extends 'EIP712Domain' ? primaryType : never)\n  domain: schema extends { EIP712Domain: infer domain }\n    ? domain\n    : Compute<Domain>\n  message?: undefined\n}\n\nexport type MessageDefinition<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData = keyof typedData,\n  ///\n  primaryTypes = typedData extends TypedData ? keyof typedData : string,\n  schema extends Record<string, unknown> = typedData extends TypedData\n    ? abitype.TypedDataToPrimitiveTypes<typedData>\n    : Record<string, unknown>,\n  message = schema[primaryType extends keyof schema\n    ? primaryType\n    : keyof schema],\n> = {\n  types: typedData\n} & {\n  primaryType:\n    | primaryTypes // show all values\n    | (primaryType extends primaryTypes ? primaryType : never) // infer value\n  domain?:\n    | (schema extends { EIP712Domain: infer domain } ? domain : Compute<Domain>)\n    | undefined\n  message: { [_: string]: any } extends message // Check if message was inferred\n    ? Record<string, unknown>\n    : message\n}\n\n/**\n * Asserts that [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.assert({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function assert<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): void {\n  const { domain, message, primaryType, types } =\n    value as unknown as assert.Value\n\n  const validateData = (\n    struct: readonly Parameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(Solidity.integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        Hex.fromNumber(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_ ?? '', 10) / 8,\n        })\n      }\n\n      if (\n        type === 'address' &&\n        typeof value === 'string' &&\n        !Address.validate(value)\n      )\n        throw new Address.InvalidAddressError({\n          address: value,\n          cause: new Address.InvalidInputError(),\n        })\n\n      const bytesMatch = type.match(Solidity.bytesRegex)\n      if (bytesMatch) {\n        const [, size] = bytesMatch\n        if (size && Hex.size(value as Hex.Hex) !== Number.parseInt(size, 10))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size, 10),\n            givenSize: Hex.size(value as Hex.Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) {\n        validateReference(type)\n        validateData(struct, value as Record<string, unknown>)\n      }\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) {\n    if (typeof domain !== 'object') throw new InvalidDomainError({ domain })\n    validateData(types.EIP712Domain, domain)\n  }\n\n  // Validate message types.\n  if (primaryType !== 'EIP712Domain') {\n    if (types[primaryType]) validateData(types[primaryType], message)\n    else throw new InvalidPrimaryTypeError({ primaryType, types })\n  }\n}\n\nexport declare namespace assert {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | Address.InvalidAddressError\n    | BytesSizeMismatchError\n    | InvalidPrimaryTypeError\n    | Hex.fromNumber.ErrorType\n    | Hex.size.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Creates [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) [`domainSeparator`](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator) for the provided domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.domainSeparator({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: '0x9911ee4f58a7059a8f5385248040e6984d80e2c849500fe6a4d11c4fa98c2af3'\n * ```\n *\n * @param domain - The domain for which to create the domain separator.\n * @returns The domain separator.\n */\nexport function domainSeparator(domain: Domain): Hex.Hex {\n  return hashDomain({\n    domain,\n  })\n}\n\nexport declare namespace domainSeparator {\n  type ErrorType = hashDomain.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Encodes typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712): `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`.\n *\n * @example\n * ```ts twoslash\n * import { TypedData, Hash } from 'ox'\n *\n * const data = TypedData.encode({ // [!code focus:33]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n * // @log: '0x19012fdf3441fcaf4f30c7e16292b258a5d7054a4e2e00dbd7b7d2f467f2b8fb9413c52c0ee5d84264471806290a3f2c4cecfc5490626bf912d01f240d7a274b371e'\n * // @log: (0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message))\n *\n * const hash = Hash.keccak256(data)\n * ```\n *\n * @param value - The Typed Data to encode.\n * @returns The encoded Typed Data.\n */\nexport function encode<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  const { domain = {}, message, primaryType } = value as encode.Value\n\n  const types = {\n    EIP712Domain: extractEip712DomainTypes(domain),\n    ...value.types,\n  } as TypedData\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  assert({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  // Typed Data Format: `0x19 ‖ 0x01 ‖ domainSeparator ‖ hashStruct(message)`\n  const parts: Hex.Hex[] = ['0x19', '0x01']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types,\n      }),\n    )\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types,\n      }),\n    )\n\n  return Hex.concat(...parts)\n}\n\nexport declare namespace encode {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType =\n    | extractEip712DomainTypes.ErrorType\n    | hashDomain.ErrorType\n    | hashStruct.ErrorType\n    | assert.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Encodes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for the provided primaryType.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.encodeType({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n * })\n * // @log: 'Foo(address address,string name,string foo)'\n * ```\n *\n * @param value - The Typed Data schema.\n * @returns The encoded type.\n */\nexport function encodeType(value: encodeType.Value): string {\n  const { primaryType, types } = value\n\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${(types[type] ?? [])\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\nexport declare namespace encodeType {\n  type Value = {\n    primaryType: string\n    types: TypedData\n  }\n\n  type ErrorType = findTypeDependencies.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Gets [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema for EIP-721 domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.extractEip712DomainTypes({\n *   name: 'Ether!',\n *   version: '1',\n *   chainId: 1,\n *   verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n * })\n * // @log: [\n * // @log:   { 'name': 'name', 'type': 'string' },\n * // @log:   { 'name': 'version', 'type': 'string' },\n * // @log:   { 'name': 'chainId', 'type': 'uint256' },\n * // @log:   { 'name': 'verifyingContract', 'type': 'address' },\n * // @log: ]\n * ```\n *\n * @param domain - The EIP-712 domain.\n * @returns The EIP-712 domain schema.\n */\nexport function extractEip712DomainTypes(\n  domain: Domain | undefined,\n): Parameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    (typeof domain?.chainId === 'number' ||\n      typeof domain?.chainId === 'bigint') && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as Parameter[]\n}\n\nexport declare namespace extractEip712DomainTypes {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing typed data in [EIP-712 format](https://eips.ethereum.org/EIPS/eip-712).\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TypedData, Hash } from 'ox'\n *\n * const payload = TypedData.getSignPayload({ // [!code focus:99]\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param value - The typed data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: encode.Value<typedData, primaryType>): Hex.Hex {\n  return Hash.keccak256(encode(value))\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) domain.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashDomain({\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0x0000000000000000000000000000000000000000',\n *   },\n * })\n * // @log: '0x6192106f129ce05c9075d319c1fa6ea9b3ae37cbd0c1ef92e2be7137bb07baa1'\n * ```\n *\n * @param value - The Typed Data domain and types.\n * @returns The hashed domain.\n */\nexport function hashDomain(value: hashDomain.Value): Hex.Hex {\n  const { domain, types } = value\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types: {\n      ...types,\n      EIP712Domain: types?.EIP712Domain || extractEip712DomainTypes(domain),\n    },\n  })\n}\n\nexport declare namespace hashDomain {\n  type Value = {\n    /** The Typed Data domain. */\n    domain: Domain\n    /** The Typed Data types. */\n    types?:\n      | {\n          EIP712Domain?: readonly Parameter[] | undefined\n          [key: string]: readonly Parameter[] | undefined\n        }\n      | undefined\n  }\n\n  type ErrorType = hashStruct.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Hashes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) struct.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.hashStruct({\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Foo',\n *   data: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: '0x996fb3b6d48c50312d69abdd4c1b6fb02057c85aa86bb8d04c6f023326a168ce'\n * ```\n *\n * @param value - The Typed Data struct to hash.\n * @returns The hashed Typed Data struct.\n */\nexport function hashStruct(value: hashStruct.Value): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return Hash.keccak256(encoded)\n}\n\nexport declare namespace hashStruct {\n  type Value = {\n    /** The Typed Data struct to hash. */\n    data: Record<string, unknown>\n    /** The primary type of the Typed Data struct. */\n    primaryType: string\n    /** The types of the Typed Data struct. */\n    types: TypedData\n  }\n\n  type ErrorType =\n    | encodeData.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Serializes [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) schema into string.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * TypedData.serialize({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: \"{\"domain\":{},\"message\":{\"address\":\"0xb9cab4f0e46f7f6b1024b5a7463734fa68e633f9\",\"name\":\"jxom\",\"foo\":\"0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9\"},\"primaryType\":\"Foo\",\"types\":{\"Foo\":[{\"name\":\"address\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"foo\",\"type\":\"string\"}]}}\"\n * ```\n *\n * @param value - The Typed Data schema to serialize.\n * @returns The serialized Typed Data schema. w\n */\nexport function serialize<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: serialize.Value<typedData, primaryType>): string {\n  const {\n    domain: domain_,\n    message: message_,\n    primaryType,\n    types,\n  } = value as unknown as serialize.Value\n\n  const normalizeData = (\n    struct: readonly Parameter[],\n    value: Record<string, unknown>,\n  ) => {\n    const data = { ...value }\n    for (const param of struct) {\n      const { name, type } = param\n      if (type === 'address') data[name] = (data[name] as string).toLowerCase()\n    }\n    return data\n  }\n\n  const domain = (() => {\n    if (!domain_) return {}\n    const type = types.EIP712Domain ?? extractEip712DomainTypes(domain_)\n    return normalizeData(type, domain_)\n  })()\n\n  const message = (() => {\n    if (primaryType === 'EIP712Domain') return undefined\n    if (!types[primaryType]) return {}\n    return normalizeData(types[primaryType], message_)\n  })()\n\n  return Json.stringify({ domain, message, primaryType, types }, (_, value) => {\n    if (typeof value === 'bigint') return value.toString()\n    return value\n  })\n}\n\nexport declare namespace serialize {\n  type Value<\n    typedData extends TypedData | Record<string, unknown> = TypedData,\n    primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n  > = Definition<typedData, primaryType>\n\n  type ErrorType = Json.stringify.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Checks if [EIP-712 Typed Data](https://eips.ethereum.org/EIPS/eip-712) is valid.\n *\n * @example\n * ```ts twoslash\n * import { TypedData } from 'ox'\n *\n * const valid = TypedData.validate({\n *   domain: {\n *     name: 'Ether!',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   primaryType: 'Foo',\n *   types: {\n *     Foo: [\n *       { name: 'address', type: 'address' },\n *       { name: 'name', type: 'string' },\n *       { name: 'foo', type: 'string' },\n *     ],\n *   },\n *   message: {\n *     address: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *     name: 'jxom',\n *     foo: '0xb9CAB4F0E46F7F6b1024b5A7463734fa68E633f9',\n *   },\n * })\n * // @log: true\n * ```\n *\n * @param value - The Typed Data to validate.\n */\nexport function validate<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(value: assert.Value<typedData, primaryType>): boolean {\n  try {\n    assert(value)\n    return true\n  } catch {\n    return false\n  }\n}\n\nexport declare namespace validate {\n  type ErrorType = assert.ErrorType | Errors.GlobalErrorType\n}\n\n/** Thrown when the bytes size of a typed data value does not match the expected size. */\nexport class BytesSizeMismatchError extends Errors.BaseError {\n  override readonly name = 'TypedData.BytesSizeMismatchError'\n\n  constructor({\n    expectedSize,\n    givenSize,\n  }: { expectedSize: number; givenSize: number }) {\n    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`)\n  }\n}\n\n/** Thrown when the domain is invalid. */\nexport class InvalidDomainError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidDomainError'\n\n  constructor({ domain }: { domain: unknown }) {\n    super(`Invalid domain \"${Json.stringify(domain)}\".`, {\n      metaMessages: ['Must be a valid EIP-712 domain.'],\n    })\n  }\n}\n\n/** Thrown when the primary type of a typed data value is invalid. */\nexport class InvalidPrimaryTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidPrimaryTypeError'\n\n  constructor({\n    primaryType,\n    types,\n  }: { primaryType: string; types: TypedData | Record<string, unknown> }) {\n    super(\n      `Invalid primary type \\`${primaryType}\\` must be one of \\`${JSON.stringify(Object.keys(types))}\\`.`,\n      {\n        metaMessages: ['Check that the primary type is a key in `types`.'],\n      },\n    )\n  }\n}\n\n/** Thrown when the struct type is not a valid type. */\nexport class InvalidStructTypeError extends Errors.BaseError {\n  override readonly name = 'TypedData.InvalidStructTypeError'\n\n  constructor({ type }: { type: string }) {\n    super(`Struct type \"${type}\" is invalid.`, {\n      metaMessages: ['Struct type must not be a Solidity type.'],\n    })\n  }\n}\n\n/** @internal */\nexport function encodeData(value: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { data, primaryType, types } = value\n  const encodedTypes: AbiParameters.Parameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType] ?? []) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return AbiParameters.encode(encodedTypes, encodedValues)\n}\n\n/** @internal */\nexport declare namespace encodeData {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | encodeField.ErrorType\n    | hashType.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function hashType(value: {\n  primaryType: string\n  types: TypedData\n}): Hex.Hex {\n  const { primaryType, types } = value\n  const encodedHashType = Hex.fromString(encodeType({ primaryType, types }))\n  return Hash.keccak256(encodedHashType)\n}\n\n/** @internal */\nexport declare namespace hashType {\n  type ErrorType =\n    | Hex.fromString.ErrorType\n    | encodeType.ErrorType\n    | Hash.keccak256.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function encodeField(properties: {\n  types: TypedData\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameters.Parameter, value: Hex.Hex] {\n  let { types, name, type, value } = properties\n\n  if (types[type] !== undefined)\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, Hash.keccak256(value, { as: 'Hex' })]\n  }\n\n  if (type === 'string')\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(Bytes.fromString(value), { as: 'Hex' }),\n    ]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameters.Parameter, any][]).map(\n      (item) =>\n        encodeField({\n          name,\n          type: parsedType,\n          types,\n          value: item,\n        }),\n    )\n    return [\n      { type: 'bytes32' },\n      Hash.keccak256(\n        AbiParameters.encode(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n\n/** @internal */\nexport declare namespace encodeField {\n  type ErrorType =\n    | AbiParameters.encode.ErrorType\n    | Hash.keccak256.ErrorType\n    | Bytes.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/** @internal */\nexport function findTypeDependencies(\n  value: {\n    primaryType: string\n    types: TypedData\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const { primaryType: primaryType_, types } = value\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined)\n    return results\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType])\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  return results\n}\n\n/** @internal */\nexport declare namespace findTypeDependencies {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/** @internal */\nfunction validateReference(type: string) {\n  // Struct type must not be a Solidity type.\n  if (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'string' ||\n    type.startsWith('bytes') ||\n    type.startsWith('uint') ||\n    type.startsWith('int')\n  )\n    throw new InvalidStructTypeError({ type })\n}\n"],
  "mappings": "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",
  "names": ["isLE", "encode", "validate", "value", "size", "struct", "encode", "validate", "fromString"]
}
